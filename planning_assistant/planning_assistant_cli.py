#!/usr/bin/env python3

import os
import sys
import argparse
from dotenv import load_dotenv
import asyncio

from autogen_agentchat.messages import TextMessage
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_agentchat.ui import Console
from autogen_agentchat.conditions import TextMentionTermination

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
from utils import find_dotenv_file
from utils.assistant_auth import PEAKAssistantAuthManager
from utils.azure_client import PEAKAssistantAzureOpenAIClient


async def plan_hunt(
    research_document: str = None,
    hypothesis: str = None,
    able_info: str = None,
    data_discovery: str = None,
    local_context: str = None,
    verbose: bool = False,
    previous_run: list = None,
) -> str:
    """
    Agent that consumes data produced by all the other PEAK Prepare-phase agents and
    produces a comprehensive plan for the hunt.

    Args:
        research_document (str): The research document containing threat hunting techniques.
        hypothesis (str): The hunting hypothesis to be tested.
        able_info (str): The Actor, Behavior, Location and Evidence (ABLE) information.
        data_discovery (str): The data discovery information.
        local_context (str): Additional local context to consider.
        verbose (bool): Whether to enable verbose output.

    Returns:
        str: The output generated by the LLM.
    """
    # Define the system prompt for the planner agent
    planner_prompt = """
        You are an expert in cybersecurity threat hunting. As the agent in charge of planning
        the hunt, your task is to create a comprehensive plan based on the provided hypothesis,
        technique/behavior research document, Actor, Behavior, Location and Evidence (ABLE) 
        information, information about the relevant data source(s) available in the Splunk server,
        and any additional local context provided. This local context may include key information 
        about the computing environment, network or Internet infrastructure, pointers for
        getting the most out of the Splunk server, or other relevant information that may be of
        use to you in your planning.

        Read the research document carefully, as well as the hypothesis that goes with it.
        Correlate these with the ABLE information, paying special attention to:
        - The Actor: Who is the threat actor, if known? Not every hunt will have a 
          specific actor, but if one is known, it may help you focus your hunt.
        - The Behavior: What is the behavior or technique that the threat actor is using?
        - The Location: Where is the threat actor operating? This may be a specific
          geographic location, a specific network, a part of the network (e.g., "the DMZ"
          or "the finance users"), or even a specific system.
        - The Evidence: What evidence is available to support the hypothesis? This may include
          specific data sources, logs, or other information that can be used to test the hypothesis.
          The data discovery information will be helpful here. The Evidence data may also include
          how the behavior is expected to manifest in the data sources, such as specific
          fields or values that are expected to be present in the data.

        Use the data discovery information to identify the relevant Splunk indices or data sources
        that contain the data needed to test the hypothesis. The data discovery information
        will provide you with a list of potential Splunk indices, their descriptions, 
        relevant sourcetypes and the key fields that are most likely to contain the 
        data needed to test the hypothesis.

        Using all this information, create a comprehensive plan for the hunt that includes:
        - A restatement of the hypothesis. Call this section "Hypothesis".
        - An estimate of the applicable time window for the hunt. Many hunts may not have 
          a specific recommendation for a time window, but certain hunts looking for 
          time-based patterns (e.g., establishing a baseline for normal activity) will benefit
          or even require a longer time window. Examples would be "Previous 30 days", "7 days",
          or "Year-to-date", but these are not the only possible values. If no specific 
          window is recommended, just write "No specific time window recommended". Call this 
          section "Recommended Time Frame".
        - A concise restatement of the ABLE information in table form. Remember to take into account
          the results of the data discovery when specifying the Evidence. 
          Call this section "ABLE Table".
        - A concise list of the relevant Splunk indices, sourcetypes, key fields, and their
          relevance to the hunt, in table form. Call this section "Data".
        - A detailed plan for the hunt, including the steps to be taken, the data sources 
          to be used, specific Splunk SPL queries to be run, and guidance on how to 
          interpret their results. Number the steps in the order in which they must be performed.
          Include any other analysis or investigation steps necessary to
          find the type of activity described in the hypothesis. You do not need to perform a 
          full incident response investigation, but you should provide enough detail to allow
          the hunter to identify the activity and determine whether it is likely to be malicious.
          Call this section "Hunt Procedure".
        
        Keep the following in mind when planning:
        - Because the Splunk indices may contain a very large amount of data, be as 
          specific as possible when specifying the data sources to be used. For example,
          when feasible, specify the index and sourcetype with all queries. Also use 
          search filters to limit the amount of data being searched, such as by specifying
          certain specific fields and values that must be present to make the events
          relevant. 
        - Instead of using traditional queries, considuer using the SPL 'tstats' command
          to search indexed data, as this is more efficient and faster than searching raw logs.

        Respond with a Markdown document containing the detailed hunt plan.  Only return
        your plan in the response, do not include any other text. Do not offer
        to provide more information or suggest additional tasks. Do not include information
        about revisions you made in response to feedback from the critic agent. The only 
        output should be the Markdown document containing the hunt plan.

        Anyone who reads this plan will already know it will be in Markdown format,
        so you never begin it with "```markdown", "```" or similar. Just start with
        the first section of the plan.
        
        When receiving feedback from a critic agent, incorporate their advice into your
        existing plan in order to provide the best quality plan.

        In the event that you are unable to create a comprehensive plan, respond with
        "Could not create a hunt plan" and provide a bullet list of the reasons why you
        could not create a plan. This will help the critic agent understand
        the limitations of your plan and provide constructive feedback.
    """

    plan_critic_prompt = """
        You are an expert in cybersecurity threat hunting. As the hunt plan critic agent,
        your task is to review the hunt plans generated by the hunt planner agent
        and provide constructive feedback to improve the quality of the plans. 

        Carefully review the provided hunting hypothesis to ensure that the plan's 
        restatement of the hypothesis is accurate to the user's original intent, then
        review the entire research document and plan to ensure that the plan is
        comprehensive, actionable, and detailed enough to allow a hunter to execute
        the hunt effectively.

        Ensure that the plan includes:
        - A restatement of the hypothesis.
        - An estimate of the applicable time window for the hunt.
        - A concise restatement of the ABLE information in table form.
        - A concise list of the relevant Splunk indices, sourcetypes, key fields, and their
          relevance to the hunt, in table form.
        - A detailed plan for the hunt, including the steps to be taken, the data sources
          to be used, specific Splunk SPL queries to be run, and guidance on how to
          interpret their results. 
        - Any other analysis or investigation steps necessary to find the type of activity
          described in the hypothesis. Especially ensure that any local context provided
          is taken into account in the plan, and that the plan is tailored to the specific
          environment and data sources available.

        Above all else, ensure that the plan and the analysis steps actually address
        the hunting hypothesis. 

        Be sure to carefully check any Splunk SPL queries provided in the plan to ensure
        that they are correct, efficient, and tailored to the data sources specified. Keep
        in mind that the Splunk indices may contain a very large amount of data, so
        the queries should be as efficient as possible. Cross-reference the queries with the 
        data discovery information to ensure that the queries are using the correct indices,
        sourcetypes, and key fields. If the queries are not efficient or do not use
        the correct indices, sourcetypes, or key fields, provide specific feedback on how to
        improve them.

        If there are any issues with the plan, if any steps are missing or unclear, 
        or if the plan does not provide enough detail to allow the hunter to execute 
        the hunt effectively or to easily interpret the query outputs, provide 
        constructive feedback to the planner agent to allow it to improve the plan. 
        Be specific about what needs to be changed and why. Be picky about the details, 
        as the hunter will rely on your feedback to improve the plan.

        If the plan is comprehensive and actionable, respond with "YYY-TERMINATE-YYY" 
        to indicate that the planner agent can stop iterating.
    """

    messages = [
        TextMessage(
            content=f"Here is the research document:\n{research_document}\n",
            source="user",
        ),
        TextMessage(content=f"Here is the hypothesis: {hypothesis}\n", source="user"),
        TextMessage(
            content=f"The Actor, Behavior, Location and Evidence (ABLE) information is as follows: {able_info}",
            source="user",
        ),
        TextMessage(
            content=f"Data discovery information: {data_discovery}\n", source="user"
        ),
        TextMessage(
            content=f"Additional local context: {local_context}\n", source="user"
        ),
    ]

    # If we have messages from a previous run, add them so we can continue the planning
    if previous_run:
        messages = messages + previous_run

    auth_mgr = PEAKAssistantAuthManager()
    #    az_model_client = await PEAKAssistantAzureOpenAIClient().get_client(auth_mgr=auth_mgr)
    az_model_reasoning_client = await PEAKAssistantAzureOpenAIClient().get_client(
        auth_mgr=auth_mgr, model_type="reasoning"
    )

    planning_agent = AssistantAgent(
        "hunt_planner",
        model_client=az_model_reasoning_client,
        system_message=planner_prompt,
    )

    plan_critic_agent = AssistantAgent(
        "hunt_plan_critic",
        model_client=az_model_reasoning_client,
        system_message=plan_critic_prompt,
    )

    # Define a termination condition that stops the task once the critic
    # agent has approved the hunt plan.
    text_termination = TextMentionTermination("YYY-TERMINATE-YYY")

    team = RoundRobinGroupChat(
        participants=[planning_agent, plan_critic_agent],
        termination_condition=text_termination,
    )

    try:
        if verbose:
            result = await Console(team.run_stream(task=messages), output_stats=True)
        else:
            result = await team.run(task=messages)
        return result
    except Exception as e:
        print(f"Error during hunt planning: {e}")
        return "An error occurred while planning the hunt."


# Example usage
if __name__ == "__main__":
    # Set up argument parser
    parser = argparse.ArgumentParser(
        description="Given the outputs of all the other Prepare-phase agents, create an actionable plan for the hunt."
    )
    parser.add_argument("-e", "--environment", help="Path to specific .env file to use")
    parser.add_argument(
        "-r",
        "--research",
        help="Path to the research document (markdown file)",
        required=True,
    )
    parser.add_argument(
        "-y", "--hypothesis", help="The hunting hypothesis", required=True
    )
    parser.add_argument(
        "-a",
        "--able_info",
        help="The Actor, Behavior, Location and Evidence (ABLE) information",
        required=False,
        default=None,
    )
    parser.add_argument(
        "-d",
        "--data_discovery",
        help="Data discovery information from previous agents",
        required=False,
        default=None,
    )
    parser.add_argument(
        "-c",
        "--local_context",
        help="Additional local context to consider",
        required=False,
        default=None,
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Enable verbose output",
        default=False,
    )
    args = parser.parse_args()

    # Load environment variables
    if args.environment:
        # Use the specified .env file
        dotenv_path = args.environment
        if not os.path.exists(dotenv_path):
            print(f"Error: Specified environment file '{dotenv_path}' not found")
            exit(1)
        load_dotenv(dotenv_path)
    else:
        # Search for .env file
        dotenv_path = find_dotenv_file()
        if dotenv_path:
            load_dotenv(dotenv_path)
        else:
            print("Warning: No .env file found in current or parent directories")

    # Read the contents of the research document
    try:
        with open(args.research, "r", encoding="utf-8") as file:
            research_data = file.read()
    except FileNotFoundError:
        print(f"Error: Research document '{args.research}' not found")
        exit(1)
    except Exception as e:
        print(f"Error reading research document: {e}")
        exit(1)

    # Read the contents of the ABLE information if provided
    able_info = None
    if args.able_info:
        try:
            with open(args.able_info, "r", encoding="utf-8") as file:
                able_info = file.read()
        except FileNotFoundError:
            print(f"Error: ABLE information file '{args.able_info}' not found")
            exit(1)
        except Exception as e:
            print(f"Error reading ABLE information: {e}")
            exit(1)

    # Read the contents of the data discovery information if provided
    data_discovery = None
    if args.data_discovery:
        try:
            with open(args.data_discovery, "r", encoding="utf-8") as file:
                data_discovery = file.read()
        except FileNotFoundError:
            print(f"Error: Data discovery file '{args.data_discovery}' not found")
            exit(1)
        except Exception as e:
            print(f"Error reading data discovery information: {e}")
            exit(1)

    # Read the contents of the local context if provided
    local_context = None
    if args.local_context:
        try:
            with open(args.local_context, "r", encoding="utf-8") as file:
                local_context = file.read()
        except FileNotFoundError:
            print(f"Error: Local context file '{args.local_context}' not found")
            exit(1)
        except Exception as e:
            print(f"Error reading local context: {e}")
            exit(1)

    messages = list()
    while True:
        # Run the hypothesizer asynchronously
        data_sources = asyncio.run(
            plan_hunt(
                hypothesis=args.hypothesis,
                research_document=research_data,
                able_info=able_info,
                data_discovery=data_discovery,
                local_context=local_context,
                verbose=args.verbose,
                previous_run=messages,
            )
        )

        # Find the final message from the "hunt_planner" agent using next() and a generator expression
        hunt_plan = next(
            (
                message.content
                for message in reversed(data_sources.messages)
                if message.source == "hunt_planner"
            ),
            None,  # Default value if no "hunt_planner" message is found
        )

        print(hunt_plan)
        feedback = input(
            "Please provide your feedback on the plan (or press Enter to approve it): "
        )

        if feedback.strip():
            # If feedback is provided, add it to the messages and loop back to
            # the research team for further refinement
            messages = [
                TextMessage(
                    content=f"The current plan draft is: {hunt_plan}\n", source="user"
                ),
                TextMessage(content=f"User feedback: {feedback}\n", source="user"),
            ]
        else:
            break
