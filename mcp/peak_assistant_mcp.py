#!/usr/bin/env python3

import os
import sys
import asyncio
import httpx 

from dotenv import load_dotenv
from pathlib import Path

from mcp.server.fastmcp import FastMCP 

# Add the parent directory to sys.path so we can import our modules
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from research_assistant.research_assistant_cli import researcher as async_researcher
from hypothesis_assistant.hypothesis_assistant_cli import hypothesizer as async_hypothesizer
from hypothesis_assistant.hypothesis_refiner_cli import refiner as async_refiner
from able_assistant.able_assistant_cli import able_table as async_able_table
from data_assistant.data_asssistant_cli import identify_data_sources as async_identify_data_sources
from planning_assistant.planning_assistant_cli import plan_hunt as async_plan_hunt

mcp = FastMCP("peak-assistant")

def find_dotenv_file():
    """Search for a .env file in current directory and parent directories"""
    current_dir = Path.cwd()
    while current_dir != current_dir.parent:  # Stop at root directory
        env_path = current_dir / '.env'
        if env_path.exists():
            return str(env_path)
        current_dir = current_dir.parent
    return None  # No .env file found

@mcp.prompt(name="peak-begin")
def peak_begin_prompt(context_filename: str) -> str:
    prompt = f"""
        In this chat session, we are going to collaboratively plan a threat hunt using the PEAK Assistant
        MCP server. Although the user may steer this workflow in any direction at any time, the expected
        sequence is:

        1. Prepare a detailed research report on a given technique or behavior (tool: peak-researcher)
        2. Display the research report to the user and ask for feedback. Collaboratively edit the report 
           until they are satisfied with the result.
        3. Decide upon a threat hunting hypothesis. This could be auto-generated by the tool (tool: peak-hypothesizer)
           OR the user can provide their own hypothesis, optionally using the tool to refine it into a 
           specific, testable form (tool: peak-hypothesis-refiner)
        4. Create the PEAK ABLE table (tool: peak-able-table)
        5. Display the ABLE table to the user and ask for feedback. Collaboratively edit the table 
           until they are satisfied with the result.
        6. Identify the data sources needed to test the hypothesis (tool: peak-data-discovery)
        7. Display the data source report to the user and ask for feedback. Collaboratively edit the report 
           until they are satisfied with the result.
        8. Plan the hunt (tool: peak-plan-hunt)
        9. Display the hunt plan to the user and ask for feedback. Collaboratively edit the plan 
           until they are satisfied with the result.

        Do your best to use this expected flow to guide the user through the process, but be flexible
        if they want to deviate from it, do things in a different order, skip steps, revisit previous 
        steps, etc.

        Here are a number of rules to guide you:
        
        - During this process, many of the tools will require a "local context". I have uploaded 
        a file called {context_filename}. When you need to know the "local context" for something, 
        use the exact contents of this file (do not summarize it).

        - Whenever you run a tool, you must display the output of the tool. You may also display
          summaries or additional information, but you must always display the tool output. When 
          feasible, display the output as an artifact.
    """
    return prompt

@mcp.prompt(name="peak-research")
def research_prompt(technique: str) -> str:
    prompt = f"""
        You are a cybersecurity threat hunter acting as a research assistant for other threat hunters. 
        Using the PEAK Assistant MCP server's researcher tool, help me compile a research report giving 
        everything a hunter should know when planning a hunt on their given topic. You should return the 
        research report as-is without modification or your own additions. 

        I have uploaded a file you can use as the local context. It is called "context.txt"
        
        ALWAYS display this report as an artifact. Display only the exact report returned from this 
        tool. Do not attempt your own analysis or summary.

        Please research the following: {technique}
    """

    return prompt 

@mcp.tool(name="peak-researcher", description="Generate a comprehensive cybersecurity threat hunting report for a specified technique or behavior.")
async def researcher(
    technique: str = None, 
    local_context: str = None
) -> str:
    """
    Orchestrates a multi-agent, multi-stage research workflow to generate a 
    comprehensive cybersecurity threat hunting report for a specified 
    technique or behavior.

    Args:
        technique (str): The name or description of the threat actor
            technique or behavior to research.
        local_context (str, optional): Additional context or constraints to guide
            the research (e.g., environment, use case). This should be the exact
            contents of the local context file, not a summary.

    Returns:
        str: A Markdown document containing the research report, or an error 
            message if the process fails.
    """
    result = await async_researcher(technique, local_context)

    report = next(
        (message.content for message in reversed(result.messages) if message.source == "summarizer"),
        None
    )

    return report

@mcp.prompt(name="peak-hypothesize")
def hypothesizer_prompt(research_document: str = None, local_context: str = None) -> str:
    prompt = f"""
        You are a cybersecurity threat hunter acting as a threat hunting assistant.
        Your job is to carefully read the provided research report and the 
        information about the local computing environment (the "local context") and 
        generate a list of threat hunting hypotheses based on those sources. Use the 
        PEAK Assistant MCP server's hypothesizer tool to generate the hypotheses.

        The research document: {research_document}

        The local context: {local_context}
    """

    return prompt

@mcp.tool(name="peak-hypothesizer", description="Generate a list of threat hunting hypotheses based on the provided research document and local computing environment context.")
async def hypothesizer(research_document: str = None, local_context: str = None) -> str:
    """
    Return a list of threat hunting hypotheses based on the provided research document
    and local computing environment context.

    Args:
        research_document (str): The exact contents of the research report.
        local_context (str, optional): Additional context or constraints to guide the research
            (e.g., environment, use case). This should be the exact contents of the local context file, 
            not a summary.

    Returns:
        str: A Markdown document containing the list of threat hunting hypotheses, or an error message if the process fails.
    """

    result = await async_hypothesizer(research_document, local_context)

    return result

@mcp.prompt(name="peak-refine-hypothesis", description="Given a threat hunting hypothesis provided by the user, provide suggest improvements to the user.")
async def refine_hypothesis_prompt(hypothesis: str = None) -> str:
    prompt = f"""
        You are a cybersecurity threat hunter acting as a threat hunting assistant.
        Your job is to carefully read the provided threat hunting hypothesis and 
        generate a list of improvements or suggestions to make the hypothesis 
        more accurate, complete, or effective. Use the PEAK Assistant MCP server's 
        hypothesis refiner tool to generate the improvements.

        The hypothesis: {hypothesis}
    """

    return prompt

@mcp.tool(name="peak-hypothesis-refiner", description="Given a threat hunting hypothesis provided by the user, provide suggest improvements to the user.")
async def hypothesis_refiner(hypothesis: str = None, research_document: str = None, local_context: str = None) -> str:
    """
    Given a threat hunting hypothesis provided by the user, provide suggest improvements to the user.

    Args:
        hypothesis (str): A threat hunting hypothesis provided by the user.
        research_document (str, optional): The exact contents of the research report.
        local_context (str, optional): Additional context or constraints to guide the research
            (e.g., environment, use case). This should be the exact contents of the local context file, 
            not a summary.

    Returns:
        str: A string containing the revised hypothesis.
    """

    result = await async_refiner(hypothesis=hypothesis, 
                                research_document=research_document, 
                                local_context=local_context)

    refined_hypothesis_message = next(
        (message.content for message in reversed(result.messages) if message.source == "critic"),
        None
    )

    refined_hypothesis = refined_hypothesis_message.replace("YYY-HYPOTHESIS-ACCEPTED-YYY", "").strip()

    return refined_hypothesis

@mcp.prompt(name="peak-able-table", description="Create the PEAK ABLE table.")
async def able_table_prompt() -> str:
    prompt = f"""
        You are a cybersecurity threat hunter acting as a threat hunting assistant.
        Your job is to carefully read the provided threat hunting research, hypothesis 
        and local context to create the "Actor, Behavior, Location, and Evidence" (ABLE)
        table.

        The research: {research_document}
        The hypothesis: {hypothesis}
        The local context: {local_context}
    """

    return prompt

@mcp.tool(name="peak-able-table", description="Create the PEAK ABLE table.")
async def able_table(hypothesis: str = None, research_document: str = None, local_context: str = None) -> str:
    """
    Create the PEAK ABLE table based on the provided hypothesis, research document, and local context.

    Args:
        hypothesis (str): A threat hunting hypothesis provided by the user.
        research_document (str, optional): The exact contents of the research report.
        local_context (str, optional): Additional context or constraints to guide the research
            (e.g., environment, use case). This should be the exact contents of the local context file, 
            not a summary.

    Returns:
        str: A Markdown document containing the ABLE table, or an error message if the process fails.
    """

    result = await async_able_table(
        hypothesis=hypothesis,
        research_document=research_document,
        local_context=local_context
    )

    return result

@mcp.tool(name="peak-data-discovery", description="Query the Splunk server to identify indices, sourctypes and key fields relevant to the hunt.")
async def data_discovery(
    hypothesis: str = None, 
    research_document: str = None, 
    able_info: str = None, 
    local_context: str = None,
    mcp_command: str = None,
    mcp_args: str = None,
    mcp_username: str = None,
    mcp_password: str = None,
    mcp_splunk_url: str = None
) -> str:
    """
    Given the provided threat hunting hypothesis, research report, ABLE table and 
    local context, query the Splunk server to try to identify indices, sourctypes 
    and key fields relevant to the hunt.

    Args:
        hypothesis (str): A threat hunting hypothesis provided by the user.
        research_document (str): The exact contents of the research report.
        able_info (str, optional): The exact contents of the ABLE table.
        local_context (str, optional): Additional context or constraints to guide the research
            (e.g., environment, use case). This should be the exact contents of the local context file, 
            not a summary.
        mcp_command (str): The command to use to start the local MCP server for querying Splunk.
        mcp_args (str): The arguments to pass to the MCP server command.
        mcp_username (str): The username to use to query the Splunk server.
        mcp_password (str): The password to use to query the Splunk server.
        mcp_splunk_url (str): The URL of the Splunk server.

    Returns:
        str: A Markdown document containing the indices, sourctypes and key fields 
             relevant to the hunt, or an error message if the process fails.
    """

    mcp_command = os.getenv("SPLUNK_MCP_COMMAND", None)
    mcp_args = os.getenv("SPLUNK_MCP_ARGS", None)

    result = await async_identify_data_sources(
        hypothesis=hypothesis,
        research_document=research_document,
        able_info=able_info,
        local_context=local_context,
        mcp_command=mcp_command,
        mcp_args=mcp_args
    )

    data_source_report = next(
        (message.content for message in reversed(result.messages) if message.source == "Data_Discovery_Agent"),
        result.messages[-1].content
    )

    return data_source_report


@mcp.tool(name="peak-hunt-planner", description="Produce a comprehensive hunting plan")
async def plan_hunt(
    hypothesis: str = None,
    research_document: str = None,
    able_info: str = None,
    data_discovery: str = None,
    local_context: str = None
) -> str:
    """
    Produce a comprehensive hunting plan based on the provided hypothesis, research document, ABLE table, 
    data discovery report, and local context.

    Args:
        hypothesis (str): A threat hunting hypothesis provided by the user.
        research_document (str): The exact contents of the research report.
        able_info (str): The exact contents of the ABLE table.
        data_discovery (str): The exact contents of the data discovery report.
        local_context (str): Additional context or constraints to guide the research
            (e.g., environment, use case). This should be the exact contents of the local context file, 
            not a summary.

    Returns:
        str: A Markdown document containing the hunting plan, or an error message if the process fails.
    """

    result = await async_plan_hunt(
        hypothesis=hypothesis,
        research_document=research_document,
        able_info=able_info,
        data_discovery=data_discovery,
        local_context=local_context
    )

    hunt_plan = next(
        (message.content for message in reversed(result.messages) if message.source == "hunt_planner"),
        None
    )

    return hunt_plan

#### MAIN ####

if __name__ == "__main__":
    load_dotenv(find_dotenv_file())
    mcp.run(transport="stdio")

