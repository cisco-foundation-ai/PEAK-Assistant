#!/usr/bin/env python3
# Copyright (c) 2025 Cisco Systems, Inc. and its affiliates
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# SPDX-License-Identifier: MIT


import uuid
import os
import argparse

from dotenv import load_dotenv

from mcp import types
from mcp.server.fastmcp import FastMCP
from pydantic.networks import AnyUrl
from ..utils import find_dotenv_file

from ..research_assistant import researcher as async_researcher
from ..research_assistant import local_data_searcher as async_local_data_searcher
from ..hypothesis_assistant.hypothesis_assistant_cli import (
    hypothesizer as async_hypothesizer,
)
from ..hypothesis_assistant.hypothesis_refiner_cli import refiner as async_refiner
from ..able_assistant import able_table as async_able_table
from ..data_assistant import (
    identify_data_sources as async_identify_data_sources,
)
from ..planning_assistant import plan_hunt as async_plan_hunt

mcp = FastMCP("peak-assistant")


def embeddable_object(
    data: str, content_type: str = "text/markdown"
) -> types.EmbeddedResource:
    """
    Create an embeddable resource from the provided data. This "encourages" the LLM chat interface
    to display the results to the user as an Artifact rather than digest and summarize it.
    """
    resource = types.TextResourceContents(
        uri=AnyUrl(f"report://{uuid.uuid4()}.md"), text=data, mimeType=content_type
    )
    return types.EmbeddedResource(
        type="resource",
        resource=resource,
        annotations=types.Annotations(audience=["user"]),
    )


################################################################################
# Prompts
################################################################################


@mcp.prompt(name="peak-begin")
def peak_begin_prompt() -> str:
    prompt = """
        In this chat session, we are going to collaboratively plan a threat hunt using the PEAK Assistant
        MCP server. Although the user may steer this workflow in any direction at any time, the expected
        sequence is:

        1. Prepare a detailed research report on a given technique or behavior (tool: peak-researcher)
        2. Display the research report to the user and ask for feedback. Collaboratively edit the report 
           until they are satisfied with the result.
        3. Decide upon a threat hunting hypothesis. This could be auto-generated by the tool (tool: peak-hypothesizer)
           OR the user can provide their own hypothesis, optionally using the tool to refine it into a 
           specific, testable form (tool: peak-hypothesis-refiner)
        4. Create the PEAK ABLE table (tool: peak-able-table)
        5. Display the ABLE table to the user and ask for feedback. Collaboratively edit the table 
           until they are satisfied with the result.
        6. Identify the data sources needed to test the hypothesis (tool: peak-data-discovery)
        7. Display the data source report to the user and ask for feedback. Collaboratively edit the report 
           until they are satisfied with the result.
        8. Plan the hunt (tool: peak-plan-hunt)
        9. Display the hunt plan to the user and ask for feedback. Collaboratively edit the plan 
           until they are satisfied with the result.

        Do your best to use this expected flow to guide the user through the process, but be flexible
        if they want to deviate from it, do things in a different order, skip steps, revisit previous 
        steps, etc.

        Here are a number of rules to guide you:
        
        - During this process, many of the tools will require a "local context". I have uploaded 
        a file containing local context information. When you need to know the "local context" for something, 
        use the exact contents of this file (do not summarize it).

        - Whenever you run an MCP tool from the PEAK Assistant, you must display the output of the tool as an artifact. 
    """
    return prompt


@mcp.prompt(name="peak-research")
def research_prompt(technique: str) -> str:
    prompt = f"""       
        Please research the following threat hunting topic and display the resulting markdown report as an artifact: {technique}
    """

    return prompt


@mcp.prompt(name="peak-hypothesize")
def hypothesizer_prompt() -> str:
    prompt = """
        You are a cybersecurity threat hunter acting as a threat hunting assistant.
        Your job is to carefully read the provided research report and the 
        information about the local computing environment (the "local context") and 
        generate a list of threat hunting hypotheses based on those sources. Use the 
        PEAK Assistant MCP server's hypothesizer tool to generate the hypotheses. Display
        the result as an artifact.
    """

    return prompt


@mcp.prompt(
    name="peak-refine-hypothesis",
    description="Given a threat hunting hypothesis provided by the user, provide suggest improvements to the user.",
)
async def refine_hypothesis_prompt() -> str:
    prompt = """
        You are a cybersecurity threat hunter acting as a threat hunting assistant.
        Your job is to carefully read the threat hunting hypothesis and 
        generate a list of improvements or suggestions to make the hypothesis 
        more accurate, complete, or effective. Use the PEAK Assistant MCP server's 
        hypothesis refiner tool to generate the improvements. Display the result as 
        an artifact.
    """

    return prompt


@mcp.prompt(name="peak-able-table", description="Create the PEAK ABLE table.")
async def able_table_prompt() -> str:
    prompt = """
        You are a cybersecurity threat hunter acting as a threat hunting assistant.
        Your job is to carefully read the provided threat hunting research, hypothesis 
        and local context to create the "Actor, Behavior, Location, and Evidence" (ABLE)
        table. Display the result as an artifact.
    """

    return prompt


@mcp.prompt(
    name="peak-data-discovery",
    description="Identify the data sources needed to test the hypothesis.",
)
async def data_discovery_prompt() -> str:
    prompt = """
        You are a cybersecurity threat hunter acting as a threat hunting assistant.
        Your job is to carefully read the provided threat hunting research, hypothesis, 
        ABLE table, and local context and then use the PEAK assistant's data discovery tool 
        to identify the indices, sourcetypes, and key fields needed to test the hypothesis. 
        Display the result as an artifact.
    """

    return prompt


@mcp.prompt(name="peak-plan-hunt", description="Produce a comprehensive hunting plan.")
async def plan_hunt_prompt() -> str:
    prompt = """
        You are a cybersecurity threat hunter acting as a threat hunting assistant.
        Your job is to carefully read the provided threat hunting research, hypothesis, 
        ABLE table, data discovery results, and local context and then use the PEAK 
        assistant's plan hunt tool to produce a comprehensive hunting plan. Display 
        the result as an artifact.
    """

    return prompt


################################################################################
# Tools
################################################################################


@mcp.tool(
    name="peak-internet-researcher",
    description="Generate a comprehensive cybersecurity threat hunting report based on Internet research for a specified technique or behavior.",
)
async def internet_researcher(technique: str, local_context: str) -> types.EmbeddedResource:
    """
    Orchestrates a multi-agent, multi-stage research workflow to generate a
    comprehensive cybersecurity threat hunting report based on Internet research 
    for a specified technique or behavior. Always display this report as an artifact.

    Args:
        technique (str): The name or description of the threat actor
            technique or behavior to research.
        local_context (str, optional): Additional context or constraints to guide
            the research (e.g., environment, use case). This should be the exact
            contents of the local context file, not a summary.

    Returns:
        types.EmbeddedResource: An embeddable resource containing the research report, or an error
             message if the process fails.
    """
    result = await async_researcher(technique, local_context)

    report = next(
        (
            getattr(message, "content")
            for message in reversed(result.messages)
            if message.source == "summarizer_agent" and hasattr(message, "content")
        ),
        "",
    )

    return embeddable_object(data=report)

@mcp.tool(
    name="peak-local-data-researcher",
    description="Search local data sources (intel databases, incident reports, ticket systems, etc) for information regarding past incidents or hunts which relate to the specified hunt technique or behavior.",
)
async def local_data_researcher(
    technique: str, 
    local_context: str,
    research_document: str
) -> types.EmbeddedResource:
    """
    Search local data sources (intel databases, incident reports, ticket systems, etc) 
    for information regarding past incidents or hunts which relate to the specified hunt 
    technique or behavior. Always display this report as an artifact.

    Args:
        technique (str): The name or description of the threat actor
            technique or behavior to research.
        local_context (str, optional): Additional context or constraints to guide
            the research (e.g., environment, use case). This should be the exact
            contents of the local context file, not a summary.
        research_document (str): The exact contents of the research document from the 
            Internet Researcher tool.

    Returns:
        types.EmbeddedResource: An embeddable resource containing the research report, or an error
             message if the process fails.
    """
    result = await async_local_data_searcher(technique, local_context, research_document)

    report = next(
        (
            getattr(message, "content")
            for message in reversed(result.messages)
            if message.source == "summarizer_agent" and hasattr(message, "content")
        ),
        "",
    )

    return embeddable_object(data=report)


@mcp.tool(
    name="peak-hypothesizer",
    description="Generate a list of threat hunting hypotheses based on the provided Internet research document, local data search results, and local computing environment context.",
)
async def hypothesizer(
    research_document: str, 
    local_context: str,
    local_data_search_results: str
) -> types.EmbeddedResource:
    """
    Return a list of threat hunting hypotheses based on the provided research document,
    local data search results, and local computing environment context.

    Args:
        research_document (str): The exact contents of the research report.
        local_context (str, optional): Additional context or constraints to guide the research
            (e.g., environment, use case). This should be the exact contents of the local context file,
            not a summary.
        local_data_search_results (str): The exact contents of the local data search results.

    Returns:
        types.EmbeddedResource: A Markdown document containing the list of threat hunting hypotheses, or an error message if the process fails.
    """
    user_input = ""
    result = await async_hypothesizer(user_input, research_document, local_context, local_data_search_results)
    return embeddable_object(data=result)


@mcp.tool(
    name="peak-hypothesis-refiner",
    description="Given a threat hunting hypothesis provided by the user, provide suggest improvements to the user.",
)
async def hypothesis_refiner(
    hypothesis: str, 
    research_document: str, 
    local_context: str,
    local_data_search_results: str
) -> types.EmbeddedResource:
    """
    Given a threat hunting hypothesis provided by the user, provide suggest improvements to the user.
    Always display this as an artifact

    Args:
        hypothesis (str): A threat hunting hypothesis provided by the user.
        research_document (str, optional): The exact contents of the research report.
        local_context (str, optional): Additional context or constraints to guide the research
            (e.g., environment, use case). This should be the exact contents of the local context file,
            not a summary.
        local_data_search_results (str): The exact contents of the local data search results.

    Returns:
        types.EmbeddedResource: An embeddable resource containing the revised hypothesis.
    """

    result = await async_refiner(
        hypothesis=hypothesis,
        research_document=research_document,
        local_context=local_context,
        local_data_document=local_data_search_results,
    )

    refined_hypothesis_message = next(
        (
            getattr(message, "content", "")
            for message in reversed(result.messages)
            if hasattr(message, "content") and message.source == "refiner"
        ),
        "",
    )

    refined_hypothesis = refined_hypothesis_message.replace(
        "YYY-HYPOTHESIS-ACCEPTED-YYY", ""
    ).strip()

    return embeddable_object(data=refined_hypothesis)


@mcp.tool(name="peak-able-table", description="Create the PEAK ABLE table.")
async def able_table(
    hypothesis: str, 
    research_document: str, 
    local_context: str,
    local_data_search_results: str
) -> types.EmbeddedResource:
    """
    Create the PEAK ABLE table based on the provided hypothesis, research document, and local context.
    Always display this as an artifact.

    Args:
        hypothesis (str): A threat hunting hypothesis provided by the user.
        research_document (str, optional): The exact contents of the research report.
        local_context (str, optional): Additional context or constraints to guide the research
            (e.g., environment, use case). This should be the exact contents of the local context file,
            not a summary.
        local_data_search_results (str): The exact contents of the local data search results.

    Returns:
        types.EmbeddedResource: An embeddable resource containing the ABLE table, or an error message if the process fails.
    """

    result = await async_able_table(
        hypothesis=hypothesis,
        research_document=research_document,
        local_context=local_context,
        local_data_document=local_data_search_results,
    )

    return embeddable_object(data=result)


@mcp.tool(
    name="peak-data-discovery",
    description="Query the Splunk server to identify indices, sourctypes and key fields relevant to the hunt.",
)
async def data_discovery(
    hypothesis: str,
    research_document: str,
    able_info: str,
    local_context: str,
    local_data_search_results: str
) -> types.EmbeddedResource:
    """
    Given the provided threat hunting hypothesis, research report, ABLE table and
    local context, query the Splunk server to try to identify indices, sourctypes
    and key fields relevant to the hunt. Always display this as an artifact.

    Args:
        hypothesis (str): A threat hunting hypothesis provided by the user.
        research_document (str): The exact contents of the research report.
        able_info (str, optional): The exact contents of the ABLE table.
        local_context (str, optional): Additional context or constraints to guide the research
            (e.g., environment, use case). This should be the exact contents of the local context file,
            not a summary.
        local_data_search_results (str): The exact contents of the local data search results.

    Returns:
        types.EmbeddedResource: An embeddable resource containing the indices, sourctypes and key fields
             relevant to the hunt, or an error message if the process fails.
    """
    result = await async_identify_data_sources(
        hypothesis=hypothesis,
        research_document=research_document,
        able_info=able_info,
        local_context=local_context,
        local_data_document=local_data_search_results,
    )

    data_source_report = next(
        (
            getattr(message, "content", None)
            for message in reversed(result.messages)
            if hasattr(message, "content") and message.source == "Data_Discovery_Agent"
        ),
        getattr(result.messages[-1], "content", None),
    )
    return embeddable_object(data=data_source_report or "No data sources found.")


@mcp.tool(name="peak-hunt-planner", description="Produce a comprehensive hunting plan")
async def plan_hunt(
    hypothesis: str,
    research_document: str,
    able_info: str,
    data_discovery: str,
    local_context: str,
    local_data_search_results: str,
) -> types.EmbeddedResource:
    """
    Produce a comprehensive hunting plan based on the provided hypothesis, research document, ABLE table,
    data discovery report, and local context. Always display this as an artifact.

    Args:
        hypothesis (str): A threat hunting hypothesis provided by the user.
        research_document (str): The exact contents of the research report.
        able_info (str): The exact contents of the ABLE table.
        data_discovery (str): The exact contents of the data discovery report.
        local_context (str): Additional context or constraints to guide the research
            (e.g., environment, use case). This should be the exact contents of the local context file,
            not a summary.
        local_data_search_results (str): The exact contents of the local data search results.

    Returns:
        types.EmbeddedResource: An embeddable resource containing the hunting plan, or an error message if the process fails.
    """

    result = await async_plan_hunt(
        hypothesis=hypothesis,
        research_document=research_document,
        able_info=able_info,
        data_discovery=data_discovery,
        local_context=local_context,
        local_data_document=local_data_search_results,
    )

    hunt_plan = next(
        (
            getattr(message, "content", None)
            for message in reversed(result.messages)
            if message.source == "hunt_planner" and hasattr(message, "content")
        ),
        None,
    )

    # If no message found from hunt_planner, try to get any message with content
    if hunt_plan is None:
        hunt_plan = next(
            (
                getattr(message, "content", None)
                for message in reversed(result.messages)
                if hasattr(message, "content") and getattr(message, "content", None) is not None
            ),
            None,
        )

    return embeddable_object(data=hunt_plan or "No hunt plan generated.")


#### MAIN ####
def main() -> None:
    # Optional CLI to set working directory without impacting unknown args
    parser = argparse.ArgumentParser(description="PEAK Assistant MCP Server", add_help=True)
    parser.add_argument("-c", "--cwd", dest="cwd", default=None, help="Set the current working directory before starting the server")
    args, _ = parser.parse_known_args()

    # If provided, set the process working directory before loading .env
    if args.cwd:
        try:
            os.chdir(args.cwd)
        except Exception as e:
            # Non-fatal: continue with existing CWD
            print(f"Warning: failed to set working directory to '{args.cwd}': {e}", flush=True)

    load_dotenv(find_dotenv_file())
    mcp.run(transport="stdio")


if __name__ == "__main__":
    main()
